# -*- coding: utf-8 -*-
"""travel ver 3.7 class ver test

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oy77zBO9MD3VNuc-bPs3J5mevJ5QQiDR
"""

# !pip install tensorflow
import tensorflow as tf

# !pip install haversine
# import subprocess

# # haversine 패키지가 설치되어 있지 않은 경우에만 설치
# try:
#     import haversine
# except ImportError:
#     subprocess.check_call(['pip', 'install', 'haversine'])

from tensorflow import keras
from keras import layers
from keras.models import load_model
import pandas as pd
from keras.saving import register_keras_serializable
import numpy as np
from tensorflow.keras import layers
from pathlib import Path
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from haversine import haversine
import random
import firebase_admin
from firebase_admin import credentials, firestore
import json
import sys
from datetime import datetime, timedelta, timezone

#통신용
import socket
global start
start = False

tour=pd.read_excel('tour_5.2.2.xls')

preparation= tour.drop_duplicates("Category")

place_id = preparation.Place_ID.tolist()

place_name = preparation.Place_Name.tolist()

place_category = preparation.Category.tolist()

place_desc = preparation.Description.tolist()

city_adress = preparation.Adress.tolist()

tourism_new = pd.DataFrame({
    "id":place_id,
    "name":place_name,
    "category":place_category,
    "description":place_desc,
    "adress":city_adress
})

data = tourism_new

cv = CountVectorizer()

cv.fit(data['adress'])

cv_matrix = cv.transform(data['adress'])

pd.DataFrame(
    cv_matrix.todense(),
    columns=list(cv.vocabulary_.keys()),
    index = data.name
).sample(5)

cosine_sim = cosine_similarity(cv_matrix)



cosine_sim_df = pd.DataFrame(cosine_sim,index=data['name'],columns=data['name'])

def tourism_recommendations(place_name,similarity_data=cosine_sim_df,items=
                            data[['name','category','description','adress']],k=5):
    index = similarity_data.loc[:,place_name].to_numpy().argpartition(range(-1,-k,-1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    closest = closest.drop(place_name,errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

df = tour

category_ids = df.Category.unique().tolist()

category_to_category_encoded = {x:i for i, x in enumerate(category_ids)}

category_encoded_to_category = {i: x for i, x in enumerate(category_ids)}

place_ids = df.Place_ID.unique().tolist()

place_to_place_encoded = {x: i for i, x in enumerate(place_ids)}

place_encoded_to_place = {x: i for x, i in enumerate(place_ids)}

df['Category'] = df.Category.map(category_to_category_encoded)

df['Place_ID'] = df.Place_ID.map(place_to_place_encoded)

num_place = num_place = len(place_encoded_to_place)
num_category= len(category_to_category_encoded)
df['Rating'] = df['Rating'].values.astype(np.float32)

min_rating = min(df['Rating'])

max_rating= max(df['Rating'])

# print(' Number of Place: {}, Min Rating: {}, Max Rating: {}'.format(
#     num_place, min_rating, max_rating
# ))

df = df.sample(frac=1,random_state=42)

@register_keras_serializable()
class RecommenderNet(tf.keras.Model):
    def __init__(self, num_category, num_place, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.num_category = num_category
        self.num_place = num_place
        self.embedding_size = embedding_size

        # Embedding layers
        self.category_embedding = layers.Embedding(
            num_category,
            embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=tf.keras.regularizers.l2(1e-6)
        )
        self.category_bias = layers.Embedding(num_category, 1)

        self.place_embedding = layers.Embedding(
            num_place,
            embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=tf.keras.regularizers.l2(1e-6)
        )
        self.place_bias = layers.Embedding(num_place, 1)

    def call(self, inputs):
        inputs = inputs[0]  # Extract the first element from the inputs tuple
        category_vector = self.category_embedding(inputs[:, 0])  # Select category ID from the first column
        category_bias = self.category_bias(inputs[:, 0])
        place_vector = self.place_embedding(inputs[:, 1])  # Select place ID from the second column
        place_bias = self.place_bias(inputs[:, 1])

        dot_user_place = tf.tensordot(category_vector, place_vector, 2)
        x = dot_user_place + category_bias + place_bias

        return tf.nn.relu(x)

    def get_config(self):
        config = super(RecommenderNet, self).get_config()
        config.update({
            'num_category': self.num_category,
            'num_place': self.num_place,
            'embedding_size': self.embedding_size
        })
        return config

    @classmethod
    def from_config(cls, config):
        return cls(**config)

model = load_model('new_model6.keras', custom_objects={'RecommenderNet': RecommenderNet})

#///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# !pip install Flask-Cors

global db

 # Firebase 인증 및 Firestore 클라이언트 설정
cred = credentials.Certificate('/home/ubuntu/travel-algorithm-app-firebase-adminsdk-p940l-014a809c9d.json')  # Firebase Admin SDK 경로 설정
firebase_admin.initialize_app(cred)  # Firebase 앱 초기화
db = firestore.client()

host = "127.0.0.1"  # 서버의 IP 주소 또는 도메인 이름
port = 12345
#import travel_algorithm

# 서버 소켓 생성
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((host, port))
server_socket.listen(5)
#received = travel_algorithm()



print(f"서버가 {host}:{port}에서 대기 중입니다...")
while True:
    # 클라이언트 연결 대기
    client_socket, client_address = server_socket.accept()
    print(f"클라이언트 {client_address}가 연결되었습니다.")

    try:
        # 클라이언트로부터 요청 받기
        while True:
          data = client_socket.recv(1024).decode("utf-8")
          if not data:
              continue
  
          global user_rec
          global user_travel   # 1차원 리스트로 초기화
          global search_last
          global search_first
          global search_second
          global search_third
          global search_travel # 첫 번째 추천 후 남은 장소들을 담는 배열
          global location_search # 유저와 가장 가까운 거리를 구하고 남은 장소와의 거리
          global last_user_rec  # 글자로 되어있는 user_rec값을 Place_ID로 변환
          global search_user_lat
          global search_user_long
          global search_travel_lat
          global search_travel_long
          global search_travel_category
          global search_second_lat
          global search_second_long
          global search_third_lat
          global search_third_long
          global user_lat
          global user_long
          global start_month
          global user_adress
          global location_user
          global remove_ids
          global travel_lat
          global travel_long
          global travel_category
          global collection_name
          global document_id
          #global data
          global travel_location
          global s_user_id, s_category, s_latitude, s_longitude, s_month, s_address, s_start_date, s_travel_name, s_dType
          user_rec = []
          user_travel = []  # 1차원 리스트로 초기화
          search_last = []
          search_first = []
          search_second = []
          search_third=[]
          search_travel = [] # 첫 번째 추천 후 남은 장소들을 담는 배열
          location_search = [] # 유저와 가장 가까운 거리를 구하고 남은 장소와의 거리
          last_user_rec = [] # 글자로 되어있는 user_rec값을 Place_ID로 변환
          search_user_lat = []
          search_user_long = []
          s_user_id = "기본값"
          s_category = [1,1,1,1,1,1,1,1,1]
          s_latitude = 37.42
          s_longitude = 127.06
          s_month = "1"
          s_address = "종로구"
          s_start_date = "2024. 10. 29. 오전 12:00:00 UTC +9"
          s_travel_name = "기본여행"
          s_dType = "예술 애호가"
  
          global remove_ids  # 전역 변수로 사용 선언
          remove_ids = []  # 초기화
          # def reciveserver(data):
  
          s_data = json.loads(data)
  
          s_user_id = s_data['userId']
          s_category = s_data['category']
          s_latitude = s_data['latitude']
          s_longitude = s_data['longitude']
          s_month = s_data['month']
          s_address = s_data['address']
          s_start_date = s_data['start_date']
          s_travel_name = s_data['travel_name']
          s_dType = s_data['Type']
  
          def recommend_places_by_category(category_id, top_n=10):
              """
              카테고리 ID를 기반으로 상위 N개의 장소를 추천하는 함수
              :param category_id: 추천하고자 하는 카테고리의 ID
              :param top_n: 추천할 장소의 개수 (기본값 10)
              :return: 추천 장소 목록
              """
              # 카테고리 인코딩
              category_encoded = category_to_category_encoded.get(category_id)
  
              # 해당 카테고리에 속하는 모든 장소의 인코딩된 ID 가져오기
              places_in_category = df[df['Category'] == category_encoded]['Place_ID'].values
  
              # 인코딩된 장소 ID들로 배열 생성
              place_encoded_array = [[place_to_place_encoded.get(place_id)] for place_id in places_in_category]
  
              # 카테고리와 장소 배열로 모델 입력 배열 생성
              category_array = np.array([[category_encoded]] * len(places_in_category))
              input_array = np.hstack((category_array, place_encoded_array))
  
              # 차원이 맞지 않는 경우 reshape
              if input_array.ndim == 1:
                  input_array = np.expand_dims(input_array, axis=0)
  
              # (None, 2) 형식으로 reshape
              input_array = input_array.reshape(-1, 2)
  
              # 모델을 이용하여 해당 카테고리의 모든 장소에 대한 평점 예측
              predicted_ratings = model.predict([input_array]).flatten()
  
              # 상위 평점을 가진 장소를 추천
              top_ratings_indices = predicted_ratings.argsort()[-top_n:][::-1]  # 상위 top_n개 평점
  
              # 일부 랜덤성을 도입해 다양한 결과가 나오도록 함
              selected_indices = random.sample(list(top_ratings_indices), min(len(top_ratings_indices), top_n))
              recommended_place_ids = [place_encoded_to_place.get(places_in_category[x]) for x in selected_indices]
  
              return recommended_place_ids
  
          user_adress = s_address# 사용자가 원하는 구(xxx구,xxx,구,없음중 택)
          category_ids = s_category
  
          # 값과 인덱스를 튜플로 묶음
          indexed_values = list(enumerate(category_ids))
  
          # 높은 순으로 정렬 (값 기준)
          sorted_indexed_values = sorted(indexed_values, key=lambda x: x[1], reverse=True)
  
          # 정렬된 값과 원래의 인덱스 출력
          sorted_values = [value for index, value in sorted_indexed_values]
          sorted_indices = [index+1 for index, value in sorted_indexed_values]
          category_ids = sorted_indices
          category_ids
  
          recommended_adresses = []
          recommended_places = []
          recommended_Big_Adress = []
          recommended_category_ids = [] # 카테고리 ID를 저장할 리스트 추가
          for i in range(len(category_ids)):
              recommended_places_ids = recommend_places_by_category(category_ids[i], top_n=50)
              recommended_adresses.append(df.loc[recommended_places_ids, 'Adress'].tolist())
              recommended_Big_Adress.append(df.loc[recommended_places_ids, 'Big_Adress'].tolist())
              recommended_places.append(df.loc[recommended_places_ids, 'Place_Name'].tolist())
  
              # recommended_places_ids를 통해 카테고리 ID를 가져와 저장
              category_ids_for_places = df.loc[recommended_places_ids, 'Category'].tolist()
              recommended_category_ids.append(category_ids_for_places)
  
  
          filtered_place_name = []

          df_score = pd.read_csv('user_score.csv')

          filtered_user_id = str(s_user_id)

          filtered_place_names = df_score[(df_score['user_Id'] == filtered_user_id) & (df_score['score'] <= 2)]['place_name']

          for place_name in filtered_place_names:
              filtered_place_name.append(place_name)

          filtered_place_name

          recommended_places = [place for place in recommended_places if place not in filtered_place_name]
  
  
          user_lat = s_latitude  ## 유저의 현재 위도 나중에 받아와야 함
          user_long = s_longitude  ##유저의 현재 경도 나중에 받아와야 함
          start_month= s_month # 이게 여행시작하는 날짜의 달을 받아와야함
          global location_user
          location_user = []
          search_travel = [] ## 남은 장소 위치 찾기
          location_search = []
          user_Id = s_user_id
  
  
          ### 이게 최신화 한거
          def user_travel_distance(x,y):## 유저와 카테고리에서 추천된 코스간 거리 추출
            km_u = []
            user_gps=(x,y) #(x(유저 위도),y(유저 경도))
            for i in range(len(user_rec)):
              km_u.append(haversine(user_gps,location_user[i]))
  
            return km_u # for 루프 밖으로 return 문을 이동합니다.
  
          def find_min(travel_user):  # 유저의 주소와 가장 가까운 장소 찾기
              if not travel_user:  # travel_user 리스트가 비어 있는지 확인합니다.
                  return None  # 비어 있다면 None을 반환합니다.
  
              mini = max(travel_user) + 1
  
              for i in range(len(travel_user)):
                  if travel_user[i] < mini:
                      mini = travel_user[i]
  
              min_indices = [i for i, val in enumerate(travel_user) if val == mini]  # mini 값을 가진 모든 인덱스를 찾습니다.
  
              if min_indices:
                  # Lat, Long, Category를 모두 비교하여 값을 반환
                  travel_xxx = df.loc[
                      (df['Lat'] == travel_lat[min_indices[0]]) &
                      (df['Long'] == travel_long[min_indices[0]]) &
                      (df['Category'] == travel_category[min_indices[0]]),
                      'Place_ID'].tolist()  # 첫 번째 mini 값을 가진 인덱스를 사용합니다.
  
                  return travel_xxx
              else:
                  return None  # mini 값을 가진 인덱스가 없으면 None을 반환합니다.
  
          def find_center(travel_search):
              if not travel_search:  # travel_search 리스트가 비어 있는지 확인합니다.
                  return None  # 비어 있다면 None 반환
  
              # 0.0을 제외한 값들을 필터링
              filtered_values = [val for val in travel_search if val > 0.0]
  
              if not filtered_values:  # 필터링 후 값이 없으면
                  return None  # None 반환
  
              center = min(filtered_values)  # 가장 작은 값
              center_indices = [i for i, val in enumerate(travel_search) if val == center]  # 최솟값의 인덱스 찾기
  
              if center_indices:
                  # Lat, Long, Category를 모두 비교하여 값을 반환
                  travel_xx = df.loc[
                      (df['Lat'] == search_travel_lat[center_indices[0]]) &
                      (df['Long'] == search_travel_long[center_indices[0]]) &
                      (df['Category'] == search_travel_category[center_indices[0]]),
                      'Place_ID'].tolist()  # 최솟값의 Place_ID
  
                  return travel_xx  # 최솟값의 Place_ID 반환
  
              return None  # 해당하는 값이 없으면 None 반환
  
          def find_third(travel_search2):
              if not travel_search2:
                  return None
  
              filtered_values2 = [val for val in travel_search2 if val > 0.0]
  
              if not filtered_values2:
                  return None
  
              third = min(filtered_values2)
  
              third_indices = [i for i, val in enumerate(travel_search2) if val == third]
  
              if third_indices:
                  # Lat, Long, Category를 모두 비교하여 값을 반환
                  travel_x = df.loc[
                      (df['Lat'] == search_travel_lat[third_indices[0]]) &
                      (df['Long'] == search_travel_long[third_indices[0]]) &
                      (df['Category'] == search_travel_category[third_indices[0]]),
                      'Place_ID'].tolist()
  
                  # 만약 추천 장소가 이미 추천된 장소일 때는 지우기
                  if travel_x == search_first:
                      filtered_values2.remove(third)
                      third = min(filtered_values2)
                      third_indices = [i for i, val in enumerate(travel_search2) if val == third]
                      travel_x = df.loc[
                          (df['Lat'] == search_travel_lat[third_indices[0]]) &
                          (df['Long'] == search_travel_long[third_indices[0]]) &
                          (df['Category'] == search_travel_category[third_indices[0]]),
                          'Place_ID'].tolist()
  
                      return travel_x
                  else:
                      return travel_x
  
              return None
  
          def search_travel_distance2(x,y):
            km_t=[]
            search_second_gps=(x[0],y[0])
            for i in range(len(search_travel)):
              km_t.append(haversine(search_second_gps,location_search[i]))
  
            return km_t
  
  
          def search_travel_distance(x,y):## 첫 번째 장소와 나머지 코스간 거리 추출
            km_s = []
            search_gps=(x[0],y[0]) # 첫 번째 장소의 (x(유저 위도),y(유저 경도))
            for i in range(len(search_travel)):
              km_s.append(haversine(search_gps,location_search[i]))
  
            return km_s # for 루프 밖으로 return 문을 이동합니다.
  
  
          ## 필요한 코드 함수화
  
  
          for i in range (len(category_ids)):
            # recommended_places의 길이를 사용하여 j 범위를 설정
            for j in range(len(recommended_places[i])):
              if user_adress == recommended_adresses[i][j]:  # recommended_adresses의 인덱스 수정
                user_travel.append(recommended_places[i][j])
                break
  
              elif user_adress == '없음':
                user_adress = recommended_adresses[0][0]
                if user_adress == recommended_adresses[i][j]:
                  user_travel.append(recommended_places[i][j])
                  break
  
              elif user_adress in ['구로구', '금천구', '동작구']:
                new_adress = '남서'
                if new_adress == recommended_Big_Adress[i][j]:
                  user_travel.append(recommended_places[i][j])
                  break
  
              elif user_adress in ['강북구', '도봉구', '노원구', '중랑구']:
                new_adress = '북동'
                if new_adress == recommended_Big_Adress[i][j]:
                  user_travel.append(recommended_places[i][j])
                  break
  
              elif user_adress in ['은평구', '서대문구']:
                new_adress = '북서 '
                if new_adress == recommended_Big_Adress[i][j]:
                  user_travel.append(recommended_places[i][j])
                  break
  
          # 겨울철일 경우 여름 관광지를 제외
          if start_month in [11,12,1,2]:  # 겨울인지 확인
              remove_ids=[]
              # 삭제할 Place_ID를 저장할 리스트
  
              for place_name in user_travel:
                  cleaned_name = place_name.strip().lower()  # 공백 제거 및 소문자 변환
                  if "여름" in cleaned_name:
                      remove_ids.append(place_name)  # Place_ID를 저장
  
              # user_travel에서 해당 Place_ID 제거
              user_travel = [place_id for place_id in user_travel if place_id not in remove_ids]
  
          # 여름철일 경우 겨울 관광지를 제외
  
          if start_month in [3, 4, 5, 6, 7, 8, 9, 10]:  # 여름인지 확인
              remove_ids=[]
              # 삭제할 Place_ID를 저장할 리스트
  
              for place_name in user_travel:
                  cleaned_name = place_name.strip().lower()  # 공백 제거 및 소문자 변환
                  if "겨울" in cleaned_name:
                      remove_ids.append(place_name)  # Place_ID를 저장
  
              # user_travel에서 해당 Place_ID 제거
              user_travel = [place_id for place_id in user_travel if place_id not in remove_ids]
  
  
          user_rec = user_travel[:4]
  
          global travel_lat
          global travel_long
          global travel_category
          travel_lat = df.loc[df['Place_Name'].isin(user_rec), 'Lat'].tolist()  #위도
          travel_long = df.loc[df['Place_Name'].isin(user_rec), 'Long'].tolist()  #경도
          travel_category= df.loc[df['Place_Name'].isin(user_rec), 'Category'].tolist()# 카테고리
  
          for i in range(len(user_rec)):
            travel_lat[i]
            travel_long[i]
            location_user.append([travel_lat[i],travel_long[i]])
  
          ## 추천 장소와 유저의 위치의 거리 구함
          travel_user = user_travel_distance(user_lat,user_long)
  
  
          if travel_user:  # travel_user 리스트가 비어 있는지 확인합니다.
            search_first =find_min(travel_user)
  
            if search_first is not None:  # search_first가 None인지 확인합니다.
              search_user_lat = df.loc[search_first, 'Lat'].tolist()  #첫 번째 장소의 위도
              search_user_long = df.loc[search_first, 'Long'].tolist()  #첫 번재 장소의 경도
  
  
          for i in range(len(user_rec)):
              if user_rec[i] is not None:  # None이 아닐 경우에만 진행
                  if user_rec[i] not in search_first:
                      search_travel.append(user_rec[i])
  
          ## 남은 장소의 위도와 경도를 구함
          search_travel_lat = df.loc[df['Place_Name'].isin(search_travel), 'Lat'].tolist()  #위도
          search_travel_long = df.loc[df['Place_Name'].isin(search_travel), 'Long'].tolist()  #경도
          search_travel_category=df.loc[df['Place_Name'].isin(search_travel), 'Category'].tolist()# 카테고리
          for i in range(len(search_travel)):
            [search_travel_lat[i],
            search_travel_long[i]]
            location_search.append([search_travel_lat[i],search_travel_long[i]])
  
          travel_search =search_travel_distance(search_user_lat,search_user_long)
  
          search_second =find_center(travel_search) or []
  
  
          search_second_lat = df.loc[search_second, 'Lat'].tolist()  #두 번째 장소의 위도
          search_second_long = df.loc[search_second, 'Long'].tolist()  #두 번째 장소의 경도
  
          travel_search2=search_travel_distance2(search_second_lat,search_second_long)
  
          search_third=find_third(travel_search2)
  
  
  
          if search_second is None:
              search_second = []
          if search_third is None:
              search_third = []
  
  
  
          last_user_rec = df.loc[df['Place_Name'].isin(user_rec), 'Place_ID'].tolist()
          if len(last_user_rec)==4:
            for i in range(len(last_user_rec)):
              # if last_user_rec[i] not in search_first and last_user_rec[i] not in search_second and last_user_rec[i] not in search_third:
              #   search_last.append(last_user_rec[i])
              if (last_user_rec[i] not in search_first and
                      last_user_rec[i] not in search_second and
                      last_user_rec[i] not in search_third):
                      search_last.append(last_user_rec[i])
          from datetime import datetime, timedelta, timezone
  
          # 주어진 날짜 문자열
          #s_start_date = '2024. 10. 16. 오후 04:36:18 UTC +9'
  
          # '오후'를 'PM', '오전'을 'AM'으로 바꾼 후 변환
          s_start_date = s_start_date.replace('오후', 'PM').replace('오전', 'AM')
  
          # 'UTC +9'를 처리하기 위해 '+9' 부분을 추출하고 timedelta로 변환
          utc_offset = int(s_start_date.split('UTC')[1].strip())
          tz_info = timezone(timedelta(hours=utc_offset))
  
          # 문자열을 datetime 객체로 변환
          dt = datetime.strptime(s_start_date.split(' UTC')[0], '%Y. %m. %d. %p %I:%M:%S')
          dt = dt.replace(tzinfo=tz_info)
  
          # 원하는 형식으로 출력
          formatted_date = dt.strftime('%Y년 %m월 %d일')
  
          ## 이거는 필요한 코드 함수화 해야함
  
          travel_location=[]
          start_potint={
              "location_name":"시작지점",
              "latitude":user_lat,
              "longitude":user_long
          }
          first_location={
                "location_name":df.loc[search_first, 'Place_Name'].values[0],
                "latitude":df.loc[search_first, 'Lat'].values[0],
                "longitude":df.loc[search_first, 'Long'].values[0]
            }
          second_location={
              "location_name":df.loc[search_second, 'Place_Name'].values[0],
              "latitude":df.loc[search_second, 'Lat'].values[0],
              "longitude":df.loc[search_second, 'Long'].values[0]
          }
          third_location={
              "location_name":df.loc[search_third, 'Place_Name'].values[0],
              "latitude":df.loc[search_third, 'Lat'].values[0],
              "longitude":df.loc[search_third, 'Long'].values[0]
          }
          last_location={
              "location_name":df.loc[search_last, 'Place_Name'].values[0],
              "latitude":df.loc[search_last, 'Lat'].values[0],
              "longitude":df.loc[search_last, 'Long'].values[0]
          }
          travel_location.append(start_potint)
          travel_location.append(first_location)
          travel_location.append(second_location)
          travel_location.append(third_location)
          travel_location.append(last_location)
  
  
  
          def save_result_to_firestore(collection_name, document_id, data):
              """지정된 컬렉션 및 문서에 데이터를 저장하거나 업데이트합니다."""
  
              doc_ref = db.collection(collection_name).document(document_id)
  
              if doc_ref.get().exists:
                  # 문서가 존재하면 업데이트
                  doc_ref.update({
                      'travel_list': firestore.ArrayUnion([data])  # 배열에 새로운 데이터를 추가
                  })
                  print(f"Data updated to {collection_name}/{document_id}")
              else:
                  # 문서가 존재하지 않으면 새로 생성
                  doc_ref.set({
                      'travel_list': [data]  # 새로운 문서에 배열로 데이터 저장
                  })
                  print(f"Data created in {collection_name}/{document_id}")
          # 처리된 데이터
          processed_data = {
              'travel_city': s_address,
              'travel_date': formatted_date,
              'travel_location': travel_location,
              'travel_name': s_travel_name,
              'theme': s_dType
          }
  
          # Firestore에 저장할 컬렉션 및 문서 ID 지정
          collection_name = 'clients'  # 저장할 컬렉션 이름
          document_id = s_user_id  # 저장할 문서 ID
  
          # Firestore에 결과 저장
          try:
              save_result_to_firestore(collection_name, document_id, processed_data)
          except Exception as e:
              print(f"Error saving data to Firestore: {e}")

    except Exception as e:
        print(f"오류 발생: {e}")